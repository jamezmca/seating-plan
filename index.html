<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seating Plan Creator</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .controls { margin-bottom: 20px; }
        .controls > * { margin-bottom: 10px; }
        label { margin-right: 10px; }
        input[type="number"] { width: 60px; }
        textarea { width: 100%; max-width: 400px; height: 100px; }
        #seating-grid { border-collapse: collapse; margin-top: 20px; }
        #seating-grid th { padding: 5px 10px; background: #eee; border: 1px solid #ccc; }
        #seating-grid td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: center;
            min-width: 80px;
            min-height: 50px;
            cursor: pointer;
            vertical-align: middle;
        }
        #seating-grid td:hover { background: #f0f0f0; }
        #seating-grid td.selected { background: #cce5ff; border: 2px solid #007bff; }
        #seating-grid td.blacked-out { background: #333; cursor: not-allowed; }
        .first-name { font-size: 1.2em; font-weight: bold; }
        .last-name { font-size: 0.8em; color: #666; }
        .empty-seat { color: #999; font-style: italic; }
        button { margin-right: 5px; margin-top: 5px; padding: 5px 10px; cursor: pointer; }
        .row-header { background: #eee; font-weight: bold; }
        #grid-container { display: inline-block; padding: 10px; background: #fff; }
        #class-header { font-size: 1.2em; font-weight: bold; text-align: center; margin-bottom: 5px; }
        #front-label { text-align: center; font-weight: bold; margin-bottom: 5px; border-bottom: 2px solid #333; padding-bottom: 5px; display: none; }
        #class-header:empty, #front-label:empty { display: none; }
        #upload-images-row { display: none; }
        @media (min-width: 769px) {
            #upload-images-row { display: block; }
        }
        .student-image { max-width: 40px; max-height: 40px; border-radius: 4px; margin-bottom: 4px; }

        /* Modal styles */
        #image-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            overflow-y: auto;
        }
        #image-modal {
            background: #fff;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            border-radius: 8px;
            position: relative;
        }
        #image-modal h2 { margin-top: 0; }
        .modal-recommendation {
            background: #e7f3ff;
            border: 1px solid #b3d7ff;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }
        .image-entries {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .image-entry {
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        .image-entry img {
            max-width: 100px;
            max-height: 100px;
            border-radius: 4px;
            margin-bottom: 8px;
        }
        .image-entry input {
            width: 100%;
            box-sizing: border-box;
            padding: 5px;
            font-size: 0.9em;
        }
        .modal-buttons {
            text-align: right;
        }
        .modal-buttons button {
            padding: 8px 16px;
            font-size: 1em;
        }
        #modal-cancel-btn {
            background: #f0f0f0;
            border: 1px solid #ccc;
        }
        #modal-add-btn {
            background: #007bff;
            color: #fff;
            border: none;
        }
        #image-settings {
            display: none;
            margin-top: 8px;
            font-size: 0.9em;
        }
        #image-count {
            color: #28a745;
            font-weight: 500;
        }
        #image-size-control {
            margin-top: 6px;
        }
        #image-size-control input[type="range"] {
            width: 120px;
            vertical-align: middle;
        }
        #image-size-value {
            display: inline-block;
            width: 45px;
            text-align: right;
        }
    </style>
</head>
<body>
    <h1>Seating Plan Creator</h1>

    <div class="controls">
        <div>
            <label>Class: <input type="text" id="class-code" placeholder="e.g., Math 101"></label>
        </div>

        <div>
            <label>Rows: <input type="number" id="rows" value="4" min="1"></label>
            <label>Columns: <input type="number" id="cols" value="5" min="1"></label>
        </div>

        <div>
            <label>Sort by:</label>
            <select id="sort-method">
                <option value="first-asc">First Name (A-Z)</option>
                <option value="first-desc">First Name (Z-A)</option>
                <option value="last-asc">Last Name (A-Z)</option>
                <option value="last-desc">Last Name (Z-A)</option>
                <option value="random">Random</option>
            </select>
        </div>

        <div>
            <label>Allocate:</label>
            <select id="allocate-direction">
                <option value="ltr">Left to Right (A &rarr; Z)</option>
                <option value="rtl">Right to Left (Z &rarr; A)</option>
            </select>
        </div>

        <div>
            <label>CSV (Last, First per line):</label><br>
            <textarea id="csv-input" placeholder="Smith, John&#10;Doe, Jane&#10;Johnson, Bob"></textarea>
        </div>

        <div>
            <label>Or upload CSV: <input type="file" id="csv-file" accept=".csv,.txt"></label>
        </div>

        <div id="upload-images-row">
            <label>Or upload images: <button id="upload-images-btn">Upload Class Images</button></label>
            <input type="file" id="image-file-input" accept="image/*" multiple style="display: none;">
            <div id="image-settings">
                <div id="image-count"></div>
                <div id="image-size-control">
                    <label>Max image size: <input type="range" id="image-size-slider" min="40" max="140" value="40"> <span id="image-size-value">40px</span></label>
                </div>
            </div>
        </div>

        <div>
            <button id="generate-btn">Generate Seating Plan</button>
        </div>

        <div>
            <label>Blackout cells (e.g., 1,A,(B,2)): <input type="text" id="blackout-input" placeholder="1,A,(B,2)"></label>
            <button id="apply-blackout">Apply Blackouts</button>
            <button id="clear-blackout">Clear Blackouts</button>
        </div>

        <div>
            <button id="export-btn">Export as PNG</button>
        </div>
    </div>

    <div id="grid-container">
        <div id="class-header"></div>
        <div id="front-label">Front of Class</div>
        <table id="seating-grid"></table>
    </div>

    <div id="image-modal-overlay">
        <div id="image-modal">
            <h2>Add Students from Images</h2>
            <div class="modal-recommendation">
                <strong>Tip:</strong> Use the format <em>LastName, FirstName</em> for each student (e.g., "Smith, John") to ensure proper sorting and display.
            </div>
            <div id="image-entries" class="image-entries"></div>
            <div class="modal-buttons">
                <button id="modal-cancel-btn">Cancel</button>
                <button id="modal-add-btn">Add Students</button>
            </div>
        </div>
    </div>

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script>
        let students = [];
        let grid = [];
        let selectedCell = null;
        let blackedOutCells = new Set();
        let studentImages = {}; // Map of "lastName,firstName" -> imageDataUrl
        let pendingImages = []; // Temporarily holds images during modal editing
        let imageMaxSize = 40; // Default max image size in px

        function updateImageSettings() {
            const imageCount = Object.keys(studentImages).length;
            const settingsDiv = document.getElementById('image-settings');
            const countDiv = document.getElementById('image-count');

            if (imageCount > 0) {
                settingsDiv.style.display = 'block';
                countDiv.textContent = `${imageCount} image${imageCount !== 1 ? 's' : ''} uploaded`;
            } else {
                settingsDiv.style.display = 'none';
            }
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            return lines.map(line => {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length >= 2) {
                    return { lastName: parts[0], firstName: parts[1] };
                }
                return null;
            }).filter(s => s !== null);
        }

        function getStudentKey(student) {
            return `${student.lastName.toLowerCase()},${student.firstName.toLowerCase()}`;
        }

        function sortStudents(students, method) {
            const sorted = [...students];
            switch(method) {
                case 'first-asc':
                    sorted.sort((a, b) => a.firstName.localeCompare(b.firstName));
                    break;
                case 'first-desc':
                    sorted.sort((a, b) => b.firstName.localeCompare(a.firstName));
                    break;
                case 'last-asc':
                    sorted.sort((a, b) => a.lastName.localeCompare(b.lastName));
                    break;
                case 'last-desc':
                    sorted.sort((a, b) => b.lastName.localeCompare(a.lastName));
                    break;
                case 'random':
                    for (let i = sorted.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [sorted[i], sorted[j]] = [sorted[j], sorted[i]];
                    }
                    break;
            }
            return sorted;
        }

        function getColumnLabel(index) {
            let label = '';
            while (index >= 0) {
                label = String.fromCharCode(65 + (index % 26)) + label;
                index = Math.floor(index / 26) - 1;
            }
            return label;
        }

        function colLabelToIndex(label) {
            label = label.toUpperCase();
            let index = 0;
            for (let i = 0; i < label.length; i++) {
                index = index * 26 + (label.charCodeAt(i) - 64);
            }
            return index - 1;
        }

        function generateGrid() {
            let rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);
            const sortMethod = document.getElementById('sort-method').value;
            const allocateDir = document.getElementById('allocate-direction').value;
            const csvText = document.getElementById('csv-input').value;

            students = parseCSV(csvText);
            students = sortStudents(students, sortMethod);

            // Auto-expand rows if needed
            const totalSeats = rows * cols;
            if (students.length > totalSeats) {
                rows = Math.ceil(students.length / cols);
                document.getElementById('rows').value = rows;
            }

            // Initialize grid
            grid = [];
            let studentIndex = 0;
            for (let r = 0; r < rows; r++) {
                grid[r] = [];
                for (let c = 0; c < cols; c++) {
                    const colIndex = allocateDir === 'rtl' ? (cols - 1 - c) : c;
                    if (studentIndex < students.length) {
                        grid[r][colIndex] = students[studentIndex++];
                    } else {
                        grid[r][colIndex] = null;
                    }
                }
            }

            blackedOutCells.clear();
            selectedCell = null;
            renderGrid();
        }

        function renderGrid() {
            const table = document.getElementById('seating-grid');
            const classHeader = document.getElementById('class-header');
            const frontLabel = document.getElementById('front-label');
            const classCode = document.getElementById('class-code').value.trim();

            const rows = grid.length;
            const cols = grid[0]?.length || 0;

            classHeader.textContent = classCode;
            frontLabel.style.display = (rows > 0 && cols > 0) ? 'block' : 'none';

            let html = '<tr><th></th>';
            for (let c = 0; c < cols; c++) {
                html += `<th>${getColumnLabel(c)}</th>`;
            }
            html += '</tr>';

            for (let r = 0; r < rows; r++) {
                html += `<tr><td class="row-header">${r + 1}</td>`;
                for (let c = 0; c < cols; c++) {
                    const cellKey = `${r},${c}`;
                    const isBlackedOut = blackedOutCells.has(cellKey);
                    const isSelected = selectedCell && selectedCell.row === r && selectedCell.col === c;

                    let cellClass = '';
                    if (isBlackedOut) cellClass = 'blacked-out';
                    else if (isSelected) cellClass = 'selected';

                    html += `<td class="${cellClass}" data-row="${r}" data-col="${c}">`;

                    if (!isBlackedOut) {
                        const student = grid[r][c];
                        if (student) {
                            const imageKey = getStudentKey(student);
                            if (studentImages[imageKey]) {
                                html += `<img src="${studentImages[imageKey]}" class="student-image" style="max-width:${imageMaxSize}px;max-height:${imageMaxSize}px;" alt="${student.firstName}">`;
                            }
                            html += `<div class="first-name">${student.firstName}</div>`;
                            html += `<div class="last-name">${student.lastName}</div>`;
                        } else {
                            html += `<div class="empty-seat">Empty</div>`;
                        }
                    }

                    html += '</td>';
                }
                html += '</tr>';
            }

            table.innerHTML = html;

            // Add click handlers
            table.querySelectorAll('td:not(.row-header)').forEach(cell => {
                cell.addEventListener('click', handleCellClick);
            });
        }

        function handleCellClick(e) {
            const cell = e.currentTarget;
            if (cell.classList.contains('blacked-out')) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            if (selectedCell === null) {
                selectedCell = { row, col };
                renderGrid();
            } else {
                // Swap
                const temp = grid[selectedCell.row][selectedCell.col];
                grid[selectedCell.row][selectedCell.col] = grid[row][col];
                grid[row][col] = temp;
                selectedCell = null;
                renderGrid();
            }
        }

        function applyBlackouts() {
            const input = document.getElementById('blackout-input').value;

            let rows = grid.length;
            const cols = grid[0]?.length || 0;

            if (rows === 0 || cols === 0) return;

            // Collect cells to black out
            const newBlackouts = new Set();

            // Parse input - numbers are rows, letters are columns, (col,row) or (row,col) for individual cells
            if (input.trim()) {
                // First extract bracketed pairs
                const pairRegex = /\(([^)]+)\)/g;
                let match;
                while ((match = pairRegex.exec(input)) !== null) {
                    const inner = match[1].split(',').map(s => s.trim());
                    if (inner.length === 2) {
                        let rowNum = null, colIdx = null;
                        inner.forEach(val => {
                            if (/^\d+$/.test(val)) {
                                rowNum = parseInt(val) - 1;
                            } else if (/^[a-zA-Z]+$/.test(val)) {
                                colIdx = colLabelToIndex(val);
                            }
                        });
                        if (rowNum !== null && colIdx !== null && rowNum >= 0 && rowNum < rows && colIdx >= 0 && colIdx < cols) {
                            newBlackouts.add(`${rowNum},${colIdx}`);
                        }
                    }
                }

                // Remove bracketed pairs and parse remaining
                const remaining = input.replace(pairRegex, '').split(',').map(s => s.trim()).filter(s => s);
                remaining.forEach(part => {
                    if (/^\d+$/.test(part)) {
                        // It's a row number
                        const r = parseInt(part) - 1;
                        if (r >= 0 && r < rows) {
                            for (let c = 0; c < cols; c++) {
                                newBlackouts.add(`${r},${c}`);
                            }
                        }
                    } else if (/^[a-zA-Z]+$/.test(part)) {
                        // It's a column letter
                        const c = colLabelToIndex(part);
                        if (c >= 0 && c < cols) {
                            for (let r = 0; r < rows; r++) {
                                newBlackouts.add(`${r},${c}`);
                            }
                        }
                    }
                });
            }

            // Collect displaced students from newly blacked out cells
            const displacedStudents = [];
            newBlackouts.forEach(cellKey => {
                if (!blackedOutCells.has(cellKey)) {
                    const [r, c] = cellKey.split(',').map(Number);
                    if (grid[r][c]) {
                        displacedStudents.push(grid[r][c]);
                        grid[r][c] = null;
                    }
                }
            });

            // Add new blackouts to the set
            newBlackouts.forEach(cell => blackedOutCells.add(cell));

            // Find empty seats for displaced students
            for (const student of displacedStudents) {
                let placed = false;
                for (let r = 0; r < grid.length && !placed; r++) {
                    for (let c = 0; c < cols && !placed; c++) {
                        const cellKey = `${r},${c}`;
                        if (!blackedOutCells.has(cellKey) && grid[r][c] === null) {
                            grid[r][c] = student;
                            placed = true;
                        }
                    }
                }

                // If no empty seat found, add a new row
                if (!placed) {
                    const newRow = [];
                    for (let c = 0; c < cols; c++) {
                        newRow.push(null);
                    }
                    grid.push(newRow);
                    // Place student in first non-blacked-out cell of new row
                    for (let c = 0; c < cols; c++) {
                        const cellKey = `${grid.length - 1},${c}`;
                        if (!blackedOutCells.has(cellKey)) {
                            grid[grid.length - 1][c] = student;
                            break;
                        }
                    }
                    document.getElementById('rows').value = grid.length;
                }
            }

            selectedCell = null;
            renderGrid();
        }

        function clearBlackouts() {
            blackedOutCells.clear();
            document.getElementById('blackout-input').value = '';

            // Collect all students from the grid
            const allStudents = [];
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[r].length; c++) {
                    if (grid[r][c]) {
                        allStudents.push(grid[r][c]);
                        grid[r][c] = null;
                    }
                }
            }

            // Redistribute students row by row
            let studentIndex = 0;
            for (let r = 0; r < grid.length && studentIndex < allStudents.length; r++) {
                for (let c = 0; c < grid[r].length && studentIndex < allStudents.length; c++) {
                    grid[r][c] = allStudents[studentIndex++];
                }
            }

            selectedCell = null;
            renderGrid();
        }

        async function exportAsPNG() {
            const gridElement = document.getElementById('seating-grid');
            if (!gridElement.innerHTML) {
                alert('Generate a seating plan first!');
                return;
            }

            try {
                const canvas = await html2canvas(document.getElementById('grid-container'));
                const link = document.createElement('a');
                link.download = 'seating-plan.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            } catch (err) {
                alert('Error exporting: ' + err.message);
            }
        }

        // Event listeners
        document.getElementById('generate-btn').addEventListener('click', generateGrid);
        document.getElementById('apply-blackout').addEventListener('click', applyBlackouts);
        document.getElementById('clear-blackout').addEventListener('click', clearBlackouts);
        document.getElementById('export-btn').addEventListener('click', exportAsPNG);

        document.getElementById('csv-file').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('csv-input').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('class-code').addEventListener('input', function(e) {
            document.getElementById('class-header').textContent = e.target.value.trim();
        });

        document.getElementById('image-size-slider').addEventListener('input', function(e) {
            imageMaxSize = parseInt(e.target.value);
            document.getElementById('image-size-value').textContent = imageMaxSize + 'px';
            if (grid.length > 0) {
                renderGrid();
            }
        });

        // Image upload functionality
        document.getElementById('upload-images-btn').addEventListener('click', function() {
            document.getElementById('image-file-input').click();
        });

        document.getElementById('image-file-input').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            pendingImages = [];
            const entriesContainer = document.getElementById('image-entries');
            entriesContainer.innerHTML = '';

            let loadedCount = 0;
            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const imageData = event.target.result;
                    // Get filename without extension
                    const fileName = file.name.replace(/\.[^/.]+$/, '');

                    pendingImages[index] = { imageData, fileName };

                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'image-entry';
                    entryDiv.innerHTML = `
                        <img src="${imageData}" alt="${fileName}">
                        <input type="text" data-index="${index}" value="${fileName}" placeholder="LastName, FirstName">
                    `;
                    entriesContainer.appendChild(entryDiv);

                    loadedCount++;
                    if (loadedCount === files.length) {
                        // All images loaded, show modal
                        document.getElementById('image-modal-overlay').style.display = 'block';
                    }
                };
                reader.readAsDataURL(file);
            });

            // Reset input so same files can be selected again
            e.target.value = '';
        });

        document.getElementById('modal-cancel-btn').addEventListener('click', function() {
            document.getElementById('image-modal-overlay').style.display = 'none';
            pendingImages = [];
        });

        document.getElementById('image-modal-overlay').addEventListener('click', function(e) {
            if (e.target === this) {
                this.style.display = 'none';
                pendingImages = [];
            }
        });

        document.getElementById('modal-add-btn').addEventListener('click', function() {
            const inputs = document.querySelectorAll('#image-entries input');
            const newStudentLines = [];

            inputs.forEach(input => {
                const index = parseInt(input.dataset.index);
                const value = input.value.trim();
                if (value && pendingImages[index]) {
                    // Parse the name
                    const parts = value.split(',').map(p => p.trim());
                    let lastName, firstName;
                    if (parts.length >= 2) {
                        lastName = parts[0];
                        firstName = parts[1];
                    } else {
                        // If no comma, treat whole thing as first name
                        lastName = '';
                        firstName = value;
                    }

                    // Store the image
                    const key = `${lastName.toLowerCase()},${firstName.toLowerCase()}`;
                    studentImages[key] = pendingImages[index].imageData;

                    // Add to CSV lines
                    newStudentLines.push(`${lastName}, ${firstName}`);
                }
            });

            // Append to existing CSV input
            const csvInput = document.getElementById('csv-input');
            if (csvInput.value.trim()) {
                csvInput.value += '\n' + newStudentLines.join('\n');
            } else {
                csvInput.value = newStudentLines.join('\n');
            }

            // Update image settings display
            updateImageSettings();

            // Close modal
            document.getElementById('image-modal-overlay').style.display = 'none';
            pendingImages = [];
        });
    </script>
</body>
</html>
