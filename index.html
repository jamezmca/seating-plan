<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seating Plan Creator</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .controls { margin-bottom: 20px; }
        .controls > * { margin-bottom: 10px; }
        label { margin-right: 10px; }
        input[type="number"] { width: 60px; }
        textarea { width: 100%; max-width: 400px; height: 100px; }
        #seating-grid { border-collapse: collapse; margin-top: 20px; }
        #seating-grid th { padding: 5px 10px; background: #eee; border: 1px solid #ccc; }
        #seating-grid td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: center;
            min-width: 80px;
            min-height: 50px;
            cursor: pointer;
            vertical-align: middle;
        }
        #seating-grid td:hover { background: #f0f0f0; }
        #seating-grid td.selected { background: #cce5ff; border: 2px solid #007bff; }
        #seating-grid td.blacked-out { background: #333; cursor: not-allowed; }
        .first-name { font-size: 1.2em; font-weight: bold; }
        .last-name { font-size: 0.8em; color: #666; }
        .empty-seat { color: #999; font-style: italic; }
        button { margin-right: 5px; margin-top: 5px; padding: 5px 10px; cursor: pointer; }
        .row-header { background: #eee; font-weight: bold; }
        #grid-container { display: inline-block; padding: 10px; background: #fff; }
        #class-header { font-size: 1.2em; font-weight: bold; text-align: center; margin-bottom: 5px; }
        #front-label { text-align: center; font-weight: bold; margin-bottom: 5px; border-bottom: 2px solid #333; padding-bottom: 5px; display: none; }
        #class-header:empty, #front-label:empty { display: none; }
        #upload-images-row { display: none; }
        @media (min-width: 769px) {
            #upload-images-row { display: block; }
        }
    </style>
</head>
<body>
    <h1>Seating Plan Creator</h1>

    <div class="controls">
        <div>
            <label>Class: <input type="text" id="class-code" placeholder="e.g., Math 101"></label>
        </div>

        <div>
            <label>Rows: <input type="number" id="rows" value="4" min="1"></label>
            <label>Columns: <input type="number" id="cols" value="5" min="1"></label>
        </div>

        <div>
            <label>Sort by:</label>
            <select id="sort-method">
                <option value="first-asc">First Name (A-Z)</option>
                <option value="first-desc">First Name (Z-A)</option>
                <option value="last-asc">Last Name (A-Z)</option>
                <option value="last-desc">Last Name (Z-A)</option>
                <option value="random">Random</option>
            </select>
        </div>

        <div>
            <label>CSV (Last, First per line):</label><br>
            <textarea id="csv-input" placeholder="Smith, John&#10;Doe, Jane&#10;Johnson, Bob"></textarea>
        </div>

        <div>
            <label>Or upload CSV: <input type="file" id="csv-file" accept=".csv,.txt"></label>
        </div>

        <div id="upload-images-row">
            <label>Or upload images: <button id="upload-images-btn">Upload Class Images</button></label>
        </div>

        <div>
            <button id="generate-btn">Generate Seating Plan</button>
        </div>

        <div>
            <label>Blackout cells (e.g., 1,A,(B,2)): <input type="text" id="blackout-input" placeholder="1,A,(B,2)"></label>
            <button id="apply-blackout">Apply Blackouts</button>
            <button id="clear-blackout">Clear Blackouts</button>
        </div>

        <div>
            <button id="export-btn">Export as PNG</button>
        </div>
    </div>

    <div id="grid-container">
        <div id="class-header"></div>
        <div id="front-label">Front of Class</div>
        <table id="seating-grid"></table>
    </div>

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script>
        let students = [];
        let grid = [];
        let selectedCell = null;
        let blackedOutCells = new Set();

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            return lines.map(line => {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length >= 2) {
                    return { lastName: parts[0], firstName: parts[1] };
                }
                return null;
            }).filter(s => s !== null);
        }

        function sortStudents(students, method) {
            const sorted = [...students];
            switch(method) {
                case 'first-asc':
                    sorted.sort((a, b) => a.firstName.localeCompare(b.firstName));
                    break;
                case 'first-desc':
                    sorted.sort((a, b) => b.firstName.localeCompare(a.firstName));
                    break;
                case 'last-asc':
                    sorted.sort((a, b) => a.lastName.localeCompare(b.lastName));
                    break;
                case 'last-desc':
                    sorted.sort((a, b) => b.lastName.localeCompare(a.lastName));
                    break;
                case 'random':
                    for (let i = sorted.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [sorted[i], sorted[j]] = [sorted[j], sorted[i]];
                    }
                    break;
            }
            return sorted;
        }

        function getColumnLabel(index) {
            let label = '';
            while (index >= 0) {
                label = String.fromCharCode(65 + (index % 26)) + label;
                index = Math.floor(index / 26) - 1;
            }
            return label;
        }

        function colLabelToIndex(label) {
            label = label.toUpperCase();
            let index = 0;
            for (let i = 0; i < label.length; i++) {
                index = index * 26 + (label.charCodeAt(i) - 64);
            }
            return index - 1;
        }

        function generateGrid() {
            let rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);
            const sortMethod = document.getElementById('sort-method').value;
            const csvText = document.getElementById('csv-input').value;

            students = parseCSV(csvText);
            students = sortStudents(students, sortMethod);

            // Auto-expand rows if needed
            const totalSeats = rows * cols;
            if (students.length > totalSeats) {
                rows = Math.ceil(students.length / cols);
                document.getElementById('rows').value = rows;
            }

            // Initialize grid
            grid = [];
            let studentIndex = 0;
            for (let r = 0; r < rows; r++) {
                grid[r] = [];
                for (let c = 0; c < cols; c++) {
                    if (studentIndex < students.length) {
                        grid[r][c] = students[studentIndex++];
                    } else {
                        grid[r][c] = null;
                    }
                }
            }

            blackedOutCells.clear();
            selectedCell = null;
            renderGrid();
        }

        function renderGrid() {
            const table = document.getElementById('seating-grid');
            const classHeader = document.getElementById('class-header');
            const frontLabel = document.getElementById('front-label');
            const classCode = document.getElementById('class-code').value.trim();

            const rows = grid.length;
            const cols = grid[0]?.length || 0;

            classHeader.textContent = classCode;
            frontLabel.style.display = (rows > 0 && cols > 0) ? 'block' : 'none';

            let html = '<tr><th></th>';
            for (let c = 0; c < cols; c++) {
                html += `<th>${getColumnLabel(c)}</th>`;
            }
            html += '</tr>';

            for (let r = 0; r < rows; r++) {
                html += `<tr><td class="row-header">${r + 1}</td>`;
                for (let c = 0; c < cols; c++) {
                    const cellKey = `${r},${c}`;
                    const isBlackedOut = blackedOutCells.has(cellKey);
                    const isSelected = selectedCell && selectedCell.row === r && selectedCell.col === c;

                    let cellClass = '';
                    if (isBlackedOut) cellClass = 'blacked-out';
                    else if (isSelected) cellClass = 'selected';

                    html += `<td class="${cellClass}" data-row="${r}" data-col="${c}">`;

                    if (!isBlackedOut) {
                        const student = grid[r][c];
                        if (student) {
                            html += `<div class="first-name">${student.firstName}</div>`;
                            html += `<div class="last-name">${student.lastName}</div>`;
                        } else {
                            html += `<div class="empty-seat">Empty</div>`;
                        }
                    }

                    html += '</td>';
                }
                html += '</tr>';
            }

            table.innerHTML = html;

            // Add click handlers
            table.querySelectorAll('td:not(.row-header)').forEach(cell => {
                cell.addEventListener('click', handleCellClick);
            });
        }

        function handleCellClick(e) {
            const cell = e.currentTarget;
            if (cell.classList.contains('blacked-out')) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            if (selectedCell === null) {
                selectedCell = { row, col };
                renderGrid();
            } else {
                // Swap
                const temp = grid[selectedCell.row][selectedCell.col];
                grid[selectedCell.row][selectedCell.col] = grid[row][col];
                grid[row][col] = temp;
                selectedCell = null;
                renderGrid();
            }
        }

        function applyBlackouts() {
            const input = document.getElementById('blackout-input').value;

            let rows = grid.length;
            const cols = grid[0]?.length || 0;

            if (rows === 0 || cols === 0) return;

            // Collect cells to black out
            const newBlackouts = new Set();

            // Parse input - numbers are rows, letters are columns, (col,row) or (row,col) for individual cells
            if (input.trim()) {
                // First extract bracketed pairs
                const pairRegex = /\(([^)]+)\)/g;
                let match;
                while ((match = pairRegex.exec(input)) !== null) {
                    const inner = match[1].split(',').map(s => s.trim());
                    if (inner.length === 2) {
                        let rowNum = null, colIdx = null;
                        inner.forEach(val => {
                            if (/^\d+$/.test(val)) {
                                rowNum = parseInt(val) - 1;
                            } else if (/^[a-zA-Z]+$/.test(val)) {
                                colIdx = colLabelToIndex(val);
                            }
                        });
                        if (rowNum !== null && colIdx !== null && rowNum >= 0 && rowNum < rows && colIdx >= 0 && colIdx < cols) {
                            newBlackouts.add(`${rowNum},${colIdx}`);
                        }
                    }
                }

                // Remove bracketed pairs and parse remaining
                const remaining = input.replace(pairRegex, '').split(',').map(s => s.trim()).filter(s => s);
                remaining.forEach(part => {
                    if (/^\d+$/.test(part)) {
                        // It's a row number
                        const r = parseInt(part) - 1;
                        if (r >= 0 && r < rows) {
                            for (let c = 0; c < cols; c++) {
                                newBlackouts.add(`${r},${c}`);
                            }
                        }
                    } else if (/^[a-zA-Z]+$/.test(part)) {
                        // It's a column letter
                        const c = colLabelToIndex(part);
                        if (c >= 0 && c < cols) {
                            for (let r = 0; r < rows; r++) {
                                newBlackouts.add(`${r},${c}`);
                            }
                        }
                    }
                });
            }

            // Collect displaced students from newly blacked out cells
            const displacedStudents = [];
            newBlackouts.forEach(cellKey => {
                if (!blackedOutCells.has(cellKey)) {
                    const [r, c] = cellKey.split(',').map(Number);
                    if (grid[r][c]) {
                        displacedStudents.push(grid[r][c]);
                        grid[r][c] = null;
                    }
                }
            });

            // Add new blackouts to the set
            newBlackouts.forEach(cell => blackedOutCells.add(cell));

            // Find empty seats for displaced students
            for (const student of displacedStudents) {
                let placed = false;
                for (let r = 0; r < grid.length && !placed; r++) {
                    for (let c = 0; c < cols && !placed; c++) {
                        const cellKey = `${r},${c}`;
                        if (!blackedOutCells.has(cellKey) && grid[r][c] === null) {
                            grid[r][c] = student;
                            placed = true;
                        }
                    }
                }

                // If no empty seat found, add a new row
                if (!placed) {
                    const newRow = [];
                    for (let c = 0; c < cols; c++) {
                        newRow.push(null);
                    }
                    grid.push(newRow);
                    // Place student in first non-blacked-out cell of new row
                    for (let c = 0; c < cols; c++) {
                        const cellKey = `${grid.length - 1},${c}`;
                        if (!blackedOutCells.has(cellKey)) {
                            grid[grid.length - 1][c] = student;
                            break;
                        }
                    }
                    document.getElementById('rows').value = grid.length;
                }
            }

            selectedCell = null;
            renderGrid();
        }

        function clearBlackouts() {
            blackedOutCells.clear();
            document.getElementById('blackout-input').value = '';

            // Collect all students from the grid
            const allStudents = [];
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[r].length; c++) {
                    if (grid[r][c]) {
                        allStudents.push(grid[r][c]);
                        grid[r][c] = null;
                    }
                }
            }

            // Redistribute students row by row
            let studentIndex = 0;
            for (let r = 0; r < grid.length && studentIndex < allStudents.length; r++) {
                for (let c = 0; c < grid[r].length && studentIndex < allStudents.length; c++) {
                    grid[r][c] = allStudents[studentIndex++];
                }
            }

            selectedCell = null;
            renderGrid();
        }

        async function exportAsPNG() {
            const gridElement = document.getElementById('seating-grid');
            if (!gridElement.innerHTML) {
                alert('Generate a seating plan first!');
                return;
            }

            try {
                const canvas = await html2canvas(document.getElementById('grid-container'));
                const link = document.createElement('a');
                link.download = 'seating-plan.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            } catch (err) {
                alert('Error exporting: ' + err.message);
            }
        }

        // Event listeners
        document.getElementById('generate-btn').addEventListener('click', generateGrid);
        document.getElementById('apply-blackout').addEventListener('click', applyBlackouts);
        document.getElementById('clear-blackout').addEventListener('click', clearBlackouts);
        document.getElementById('export-btn').addEventListener('click', exportAsPNG);

        document.getElementById('csv-file').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('csv-input').value = e.target.result;
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('class-code').addEventListener('input', function(e) {
            document.getElementById('class-header').textContent = e.target.value.trim();
        });
    </script>
</body>
</html>
